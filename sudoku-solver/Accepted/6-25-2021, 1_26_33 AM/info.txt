{"id":512704182,"lang":"java","time":"1Â month","timestamp":1624564593,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/512704182/","is_pending":"Not Pending","title":"Sudoku Solver","memory":"36.5 MB","code":"class Solution {\n\n    /**\n     * State of a bitset where all digits [1..9] are present.\n     */\n    private static final int ALL_SET = 0b111_111_111_0;\n\n    /**\n     * Box indices by row and column. Don't recompute what can be a constant :-)\n     */\n    private static final int[][] BOX_INDICES = {\n            {0, 0, 0, 1, 1, 1, 2, 2, 2},\n            {0, 0, 0, 1, 1, 1, 2, 2, 2},\n            {0, 0, 0, 1, 1, 1, 2, 2, 2},\n            {3, 3, 3, 4, 4, 4, 5, 5, 5},\n            {3, 3, 3, 4, 4, 4, 5, 5, 5},\n            {3, 3, 3, 4, 4, 4, 5, 5, 5},\n            {6, 6, 6, 7, 7, 7, 8, 8, 8},\n            {6, 6, 6, 7, 7, 7, 8, 8, 8},\n            {6, 6, 6, 7, 7, 7, 8, 8, 8}\n    };\n\n    /**\n     * This helper object provides a convenient API to iterate over the not-yet-filled cells of the Sudoku board.\n     */\n    private final SudokuSequence sequence = new SudokuSequence();\n\n    /**\n     * Current Sudoku board.\n     */\n    private char[][] board;\n\n\n    ////// THE SOLUTION //////\n    public void solveSudoku(char[][] board) {\n        this.board = board;\n        // fill the sequence\n        sequence.init();\n        for (int row = 0; row < 9; row++) {\n            for (int col = 0; col < 9; col++) {\n                char c = board[row][col];\n                if (c == '.') {\n                    sequence.add(row, col);\n                    continue;\n                }\n                sequence.flip(row, col, c - '0');\n            }\n        }\n        if (!solve(0)) {\n            throw new IllegalArgumentException(\"Unsolvable Sudoku!\");\n        }\n    }\n\n    /**\n     * Performs DFS (with some optimization) to find the first valid solution of the Sudoku puzzle ({@link #board}).\n     * <p>Invalid solutions (dead-ends) are reverted to the last valid state (backtracking), never to be considered again.\n     *\n     * @param position current position of a cell in the {@link #sequence}\n     * @return true if solution was found, false if it can't be found for a given state of the board\n     */\n    private boolean solve(int position) {\n        if (position == sequence.size) return true; // base case: we reached the end and all the cells can be filled\n\n        int easiest = sequence.easiest(position);\n        if (easiest < 0) {\n            return false;\n        }\n        sequence.swap(position, easiest); // move the easiest cell to the current position\n\n        int row = sequence.row(position);\n        int col = sequence.col(position);\n        int set = sequence.digits(position);\n\n        for (int lo = 1, digit; lo <= 9; lo = digit + 1) {\n            digit = nextDigit(set, lo);\n            if (digit > 9) break;\n\n            sequence.flip(row, col, digit); // place the digit\n\n            // proceed with the DFS\n            if (solve(position + 1)) {\n                board[row][col] = (char) ('0' + digit); // fill the board as the recursion unwinds\n                return true;\n            }\n            // if a solution is not found, backtrack and try the next digit\n\n            sequence.flip(row, col, digit);\n        }\n        sequence.swap(position, easiest); // revert modification to the sequence\n        return false;\n    }\n\n\n    /**\n     * Calculates the next digit absent from a set.\n     *\n     * @param set    bitset of placed digits\n     * @param lowest lowest digit to consider\n     * @return digit [1..9] if available or some value > 9 if the all the bits [1..9] are 1-s\n     */\n    private static int nextDigit(int set, int lowest) {\n        set >>>= lowest;\n        return Integer.numberOfTrailingZeros(~set) + lowest;\n    }\n\n    /**\n     * Calculates the box index for given cell on a board.\n     *\n     * @param row column index\n     * @param col row index\n     * @return box index\n     */\n    private static int box(int row, int col) {\n        return BOX_INDICES[row][col];\n    }\n\n    /**\n     * This auxiliary class represents a sequence of unfilled Sudoku cells.\n     * It is implemented as a structure of arrays (SoA) to reduce the need for heap allocations.\n     */\n    private static final class SudokuSequence {\n\n        /**\n         * Bitmap of the present digits by row.\n         *\n         * @see #digits\n         */\n        int[] rows;\n\n        /**\n         * Bitmap of the present digits by column.\n         */\n        int[] cols;\n\n        /**\n         * Bitmap of the present digits by box.\n         */\n        int[] boxes;\n\n        /**\n         * Mapping of the sequence position to the row index on the board.\n         */\n        final int[] rowSeq = new int[81];\n\n        /**\n         * Mapping of the sequence position to the column index on the board.\n         */\n        final int[] colSeq = new int[81];\n\n        /**\n         * Actual size of the sequence (number of the unfilled cells on the initial board).\n         */\n        int size;\n\n        /**\n         * Resets the state of the sequence.\n         * <p>{@link #rowSeq} and {@link #colSeq} and not re-allocated,\n         * we will just overwrite old values as we add new onex.\n         */\n        void init() {\n            rows = new int[9];\n            cols = new int[9];\n            boxes = new int[9];\n            size = 0;\n        }\n\n        /**\n         * Add a new entry into the sequence.\n         *\n         * @param row row index\n         * @param col column index\n         */\n        void add(int row, int col) {\n            rowSeq[size] = row;\n            colSeq[size] = col;\n            size++;\n        }\n\n        /**\n         * Given a starting position in this sequence,\n         * finds in its remaining part the position which is the easiest to fill.\n         * <p>Easiest here meaning that it can be filled with the least amount of possible digits, ideally just 1\n         * (meaning that the rest 8 digits are already present in the respective row, column and box).\n         * <p>This rather basic heuristic allows us to dramatically prune the branches of our DFS.\n         * Given that most sudoku puzzles have only 1 valid solution meant to be found by a human,\n         * there should almost always be a cell on a board which has only 1 valid value.\n         *\n         * @param from lower bound of the search\n         * @return position that is the easiest to fill, or -1 if it can't be found or if the sequence state is invalid\n         */\n        int easiest(int from) {\n            int easiest = -1, maxPopulation = 0;\n            for (int i = from; i < size; i++) {\n                int set = digits(i);\n                if (set == ALL_SET) return -1; // if all digits are taken, then current solution is invalid\n                int population = Integer.bitCount(set);\n\t\t\t\tif (population == 8) return i;\n                if (population > maxPopulation) {\n                    easiest = i;\n                    maxPopulation = population;\n                }\n            }\n            return easiest;\n        }\n\n        /**\n         * Swaps two values in the sequence.\n         *\n         * @param p1 position of the first cell in this sequence\n         * @param p2 position of the second cell in this sequence\n         */\n        void swap(int p1, int p2) {\n            int tmpR = rowSeq[p1], tmpC = colSeq[p1];\n            rowSeq[p1] = rowSeq[p2];\n            rowSeq[p2] = tmpR;\n            colSeq[p1] = colSeq[p2];\n            colSeq[p2] = tmpC;\n        }\n\n        /**\n         * Builds a bitset that contains the digits that are present in the row, column and box of a given cell.\n         * <p>Digits are stored as 1-flags in their respective positions e.g. set with value {@code 0b101_000_001_0}\n         * indicates the presence of the digits '1', '7', and '9'.\n         * <p>The usage of bitsets here allows for an extremely efficient checking of the problem's core constraint.\n         * Using some trickery {@link #nextDigit(int, int)} we can even iterate over just the un-placed digits in such a set.\n         *\n         * @param position position of the cell in this sequence\n         * @return bitset of present digits\n         */\n        int digits(int position) {\n            int ri = rowSeq[position], ci = colSeq[position], bi = box(ri, ci);\n            return rows[ri] | cols[ci] | boxes[bi];\n        }\n\n        /**\n         * Returns a row index of a cell.\n         *\n         * @param position position of a cell in this sequence\n         * @return row index\n         */\n        int row(int position) {\n            return rowSeq[position];\n        }\n\n        /**\n         * Returns a column index of a cell.\n         *\n         * @param position position of a cell in this sequence\n         * @return column index\n         */\n        int col(int position) {\n            return colSeq[position];\n        }\n\n        /**\n         * Flips the bit that indicates the presence of a digit in the given row, column, and box.\n         *\n         * @param row row index\n         * @param col column index\n         * @param val digit to set/unset\n         */\n        void flip(int row, int col, int val) {\n            int bit = 1 << val;\n            rows[row] ^= bit;\n            cols[col] ^= bit;\n            boxes[box(row, col)] ^= bit;\n        }\n    }\n\n}","compare_result":"111111","title_slug":"sudoku-solver"}