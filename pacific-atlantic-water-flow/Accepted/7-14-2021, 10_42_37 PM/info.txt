{"id":522536577,"lang":"java","time":"1 week, 3 days","timestamp":1626282757,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/522536577/","is_pending":"Not Pending","title":"Pacific Atlantic Water Flow","memory":"40.3 MB","code":"import java.util.*;\n\n//B F S\n\nclass Solution {\n    int[][] heights;\n\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        this.heights = heights;\n        List<List<Integer>> res = new LinkedList<>();\n\n        // Define Queue\n        Queue<int[]> queue = new LinkedList<>();\n\n        // Add coordinates from first row and first col to the queue\n        int M = heights.length, N = heights[0].length;\n        addRow(0, queue, N);\n        addCol(0, queue, M);\n\n        // return a visited table that BFS to visit coordinates in the queue\n        boolean[][] pacificTable = BFS(queue, M, N);\n\n        // Add coordinate from the last row and last col to the queue\n        addRow(M - 1, queue, N);\n        addCol(N - 1, queue, M);\n\n        // return a visited table that BFS to visit coordinates in the queue\n        boolean[][] atlanticTable = BFS(queue, M, N);\n\n        // add coordinates that are both visited from two tables to the res list\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                if (atlanticTable[i][j] == true && pacificTable[i][j] == true) {\n                    res.add(Arrays.asList(new Integer[] { i, j }));\n                }\n            }\n        }\n        // return the res list\n        return res;\n    }\n\n    private boolean[][] BFS(Queue<int[]> queue, int M, int N) {\n        // Create a new table\n        boolean[][] visited = new boolean[M][N];\n        // BFS all 4 directions and make visited cell true in the table\n        while (queue.isEmpty() == false) {\n            int[] first = queue.poll();\n            int row = first[0];\n            int col = first[1];\n            if (visited[row][col] == true)\n                continue;\n            visited[row][col] = true;\n            int curCellVal = heights[row][col];\n            // Top\n            if (0 <= row - 1 && heights[row - 1][col] >= curCellVal && visited[row - 1][col] == false) {\n                queue.add(new int[] { row - 1, col });\n            }\n            // Left\n            if (0 <= col - 1 && heights[row][col - 1] >= curCellVal && visited[row][col - 1] == false) {\n                queue.add(new int[] { row, col - 1 });\n            }\n            // Right\n            if (col + 1 < N && heights[row][col + 1] >= curCellVal && visited[row][col + 1] == false) {\n                queue.add(new int[] { row, col + 1 });\n            }\n            // Down\n            if (row + 1 < M && heights[row + 1][col] >= curCellVal && visited[row + 1][col] == false) {\n                queue.add(new int[] { row + 1, col });\n            }\n        }\n        // return the table\n        return visited;\n    }\n\n    private void addRow(int row, Queue<int[]> queue, int totalCols) {\n        for (int i = 0; i < totalCols; i++) {\n            int col = i;\n            int[] coor = { row, col };\n            queue.add(coor);\n        }\n    }\n\n    private void addCol(int col, Queue<int[]> queue, int totalRows) {\n        for (int i = 0; i < totalRows; i++) {\n            int row = i;\n            int[] coor = { row, col };\n            queue.add(coor);\n        }\n    }\n}\n\n//First row and first column can reach the pacific ocean\n//Last row and last column can reach the atlantic ocean\n//Start from the above two types of positions and try to go inwards as long as you are on a cell having higher value than the boundary cell you're coming from\n//Find common between pacific and atlantic visited tables Are the desired answers!\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"pacific-atlantic-water-flow"}