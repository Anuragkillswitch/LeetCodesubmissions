{"id":523906622,"lang":"java","time":"1Â week","timestamp":1626527910,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/523906622/","is_pending":"Not Pending","title":"Three Equal Parts","memory":"45.2 MB","code":"class Solution {\n      public int[] threeEqualParts(int[] A) {\n    int numOne = 0;\n    for (int i: A) if (i == 1) numOne++;\n\n    int[] res = {-1, -1};\n    if (numOne == 0) return new int[]{0,2}; // special case\n    if (numOne % 3 != 0) return res;\n\n    int thirdPartStartingIndex = 0;\n    int count = 0;\n    for (int i = A.length - 1; i >= 0; --i){\n        if (A[i] == 1){\n            if (++count == numOne / 3){\n                thirdPartStartingIndex = i;\n                break;\n            }\n        }\n    }\n\n    int firstPartEndIndex = findNextEndIndexAndCompare(A, 0, thirdPartStartingIndex);\n    if (firstPartEndIndex < 0) return res;\n\n    int secondPartEndIndex = findNextEndIndexAndCompare(A, firstPartEndIndex + 1, thirdPartStartingIndex);\n    if (secondPartEndIndex < 0) return res;\n\n    return new int[]{firstPartEndIndex, secondPartEndIndex+1};\n}\n\n\n/** the implementation idea is similar to find last k node in a list\n *  in the sense that pacer is a pacer\n *  when the pacer reaches the end, the end for the current part has been anchored\n *  Note: we also do the comparing for the two parts of interest\n *\n * @param A\n * @param start\n * @param pacer\n * @return\n */\nprivate int findNextEndIndexAndCompare(int[] A, int start, int pacer){\n    while (A[start] == 0) start++;\n    while (pacer < A.length){\n        if (A[start] != A[pacer]) return -1;\n        start++;\n        pacer++;\n    }\n    return start - 1;\n}\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"three-equal-parts"}