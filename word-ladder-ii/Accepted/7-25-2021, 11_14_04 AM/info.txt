{"id":527915865,"lang":"java","time":"1 hour, 52 minutes","timestamp":1627191844,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/527915865/","is_pending":"Not Pending","title":"Word Ladder II","memory":"39.5 MB","code":"class Solution {\n    Map<String, List<String>> adjList = new HashMap<String, List<String>>();\n    List<String> currPath = new ArrayList<String>();\n    List<List<String>> shortestPaths = new ArrayList<List<String>>();\n    \n    private List<String> findNeighbors(String word, Set<String> wordList) {\n        List<String> neighbors = new ArrayList<String>();\n        char charList[] = word.toCharArray();\n        \n        for (int i = 0; i < word.length(); i++) {\n            char oldChar = charList[i];   \n            \n            // replace the i-th character with all letters from a to z except the original character\n            for (char c = 'a'; c <= 'z'; c++) {\n                charList[i] = c;\n                \n                // skip if the character is same as original or if the word is not present in the wordList\n                if (c == oldChar || !wordList.contains(String.valueOf(charList))) {\n                    continue;\n                }\n                neighbors.add(String.valueOf(charList));\n            }\n            charList[i] = oldChar;\n        }\n        return neighbors;\n    }\n    \n    private void backtrack(String source, String destination) {\n        //System.out.printlen(source);\n        // store the path if we reached the endWord\n        if (source.equals(destination)) {\n            List<String> tempPath = new ArrayList<String>(currPath);\n            shortestPaths.add(tempPath);\n        }\n        \n        if (!adjList.containsKey(source)) {\n            return;\n        }\n        \n        for (int i = 0; i < adjList.get(source).size(); i++) {\n            currPath.add(adjList.get(source).get(i));\n            backtrack(adjList.get(source).get(i), destination);\n            currPath.remove(currPath.size() - 1);\n        }\n    }\n    \n    private void swap(Set<String> forward, Set<String> backward) {\n        Set<String> temp = forward;\n        forward = backward;\n        backward = temp;\n    }\n    private void addEdge(String word1, String word2, int direction) {\n        if(direction == 1) {\n            if (!adjList.containsKey(word1)) {\n                adjList.put(word1, new ArrayList<String>());\n        }\n            adjList.get(word1).add(word2);\n        } else {\n             if (!adjList.containsKey(word2)) {\n                adjList.put(word2, new ArrayList<String>());\n        }\n            adjList.get(word2).add(word1);\n        }\n    }\n    \n    private boolean bfs(String beginWord, String endWord, Set<String> wordList) {\n        if (wordList.contains(endWord) == false) {\n            return false;\n        }\n        \n        // remove the root word which is the first layer\n        if (wordList.contains(beginWord)) {\n            wordList.remove(beginWord);\n        }\n\n        Set<String> forwardQueue =  new HashSet<String>();\n        Set<String> backwardQueue = new HashSet<String>();\n        \n        forwardQueue.add(beginWord);\n        backwardQueue.add(endWord);\n        \n        boolean found = false;\n        int direction = 1;\n        \n        while (forwardQueue.isEmpty() != true)  {\n            // visited will store the words of current layer\n             Set<String> visited = new HashSet<String>();\n           \n            // swap the queues because we are always extending the forwardQueue\n            if (forwardQueue.size() > backwardQueue.size()) {\n                Set<String> temp = forwardQueue;\n                 forwardQueue = backwardQueue;\n                 backwardQueue = temp;\n                 direction ^= 1;\n            }\n            \n            for (String currWord : forwardQueue) {\n                List<String> neighbors = findNeighbors(currWord, wordList);\n                 for (String word : neighbors) {\n                     \n                      // if the backwardQueue already contains it we can stop after completing this level\n                     if (backwardQueue.contains(word)) {\n                         found = true;\n                         addEdge(currWord, word, direction);\n                     } \n                     \n                     /* the word shouldn't be presnt in forwardQueue because if it is then the edge will\n                     be between two words at the same level which we don't want */\n                     else if (!found && wordList.contains(word) == true && forwardQueue.contains(word) == false) {\n                         visited.add(word);\n                         addEdge(currWord, word, direction);\n                     }\n                 }\n            }\n            \n            // removing the words of the previous layer\n            for (String currWord : forwardQueue) {\n                if (wordList.contains(currWord)) {\n                    wordList.remove(currWord);\n                }\n            }\n            \n            if (found) {\n                break;\n            }\n\n            forwardQueue = visited;\n        }\n        return found;\n    }\n    \n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        // copying the words into the set for efficient deletion in BFS\n        Set<String> copiedWordList = new HashSet<>(wordList);\n        // build the DAG using BFS\n        boolean sequence_found = bfs(beginWord, endWord, copiedWordList);\n        \n        // There is no valid sequence that connects `beginWord` to `endWord`\n        if (sequence_found == false) {\n            return shortestPaths;\n        }\n        // every path will start from the beginWord\n        currPath.add(beginWord);\n        // traverse the DAG to find all the paths between beginWord and endWord\n        backtrack(beginWord, endWord);\n        \n        return shortestPaths;\n    }\n}","compare_result":"11111111111111111111111111111111","title_slug":"word-ladder-ii"}