{"id":484572834,"lang":"python3","time":"3Â months","timestamp":1619268024,"status_display":"Accepted","runtime":"2360 ms","url":"/submissions/detail/484572834/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"86.2 MB","code":"class Solution:\n    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        '''\n        disc = discovery time of each node in the graph\n        _____________________\n        |The concept of 'LOW'|\n        low values means to which scc this node belongs to and that if this node is reachable to\n        its ancestor (basically is there any way ,  if yes then we assign the low value of this node to the low value of its ancestor which will signify that this node belongs to the SCC and that the edge from this node to the ancestor node is the back edge\n        when this node will backtrack to its parent node then it will say that look the connection between you(Parent) and me(child) is not a critical connection because I can be dicovered without your help(Parent) and we all belong to one SCC hence we update the parents low value to the min of low[parent],low[child])\n        Next imp thing : \n        _____________________________________________\n        |Condition to check if this edge is a bridge | \n        \n        eg : SCC1 -----> SCC2\n            disc=0       disc =1\n            low=0        low=1\n        SCC1 =      1->2->3->1           SCC2= 4->5->4\n             disc   0  1  2  0           disc   3  4  3\n             low    0  0  0  0           low    3  3  3\n             \n        suppose there s an edge from 1 to 4 and we start our dfs from node 1 then we know that \n        the discovery of node 1 is done before the discovery of node 4 \n        now we cant simply compare the dicovery time of the nodes(thats not correct)\n        hence we use the low value of the chid to check \n        ___________________________________\n        | if dicovery[parent] < low[child] |\n        MEANS , That the dicovery ofthe parent was done before that of child hence its value is small if the edge is critical edge \n        else if this edge is not a critical edge then the low value of the child is lesser than or equal to parent\n        '''\n        disc = [-1]*n\n        low = [-1]*n\n        self.time = 0\n        graph = defaultdict(list)\n        bridges = []\n        for u,v in connections:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node,parent):\n            #print(parent)\n            if disc[node] != -1:\n                return \n            \n            disc[node] = self.time\n            low[node] = self.time\n            self.time += 1\n            \n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                dfs(neighbor,node)\n                \n                low[node] = min(low[neighbor],low[node])\n                \n                if disc[node] < low[neighbor] :\n                    bridges.append([node,neighbor])\n                    \n        dfs(0,-1)\n        #print(low)\n        return bridges\n                    ","compare_result":"111111111111","title_slug":"critical-connections-in-a-network"}