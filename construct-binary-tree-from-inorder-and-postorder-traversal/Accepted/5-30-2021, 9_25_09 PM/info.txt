{"id":500433225,"lang":"java","time":"1 month, 3 weeks","timestamp":1622390109,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/500433225/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"38.8 MB","code":"class Solution {\n    \n    public int postRootIndex;\n    \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        \n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int i = 0; i < inorder.length; i++){\n            map.put(inorder[i], i);\n        }\n        postRootIndex = postorder.length - 1;\n        \n        return Util(inorder, postorder, map, 0, inorder.length - 1);\n    }\n    \n    public TreeNode Util(int[] inorder, int[] postorder, HashMap<Integer, Integer> map, int start, int end){\n        if(start > end) \n            return null;\n        \n        TreeNode root = new TreeNode(postorder[postRootIndex--]);\n        \n        if(start == end)\n            return root;\n        \n        int inRootIndex = map.get(root.val);\n        \n        root.right = Util(inorder, postorder, map, inRootIndex + 1, end);\n        root.left = Util(inorder, postorder, map, start, inRootIndex - 1);\n        return root;\n    }\n    \n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal"}