{"id":513431604,"lang":"java","time":"4Â weeks","timestamp":1624714817,"status_display":"Accepted","runtime":"110 ms","url":"/submissions/detail/513431604/","is_pending":"Not Pending","title":"Count of Smaller Numbers After Self","memory":"131 MB","code":"class Solution {\n    class TreeNode {\n        int val;\n        int height;\n        \n        int freq;       // frequency of node with val\n        int countLeft;  // number of nodes in TreeNode left (with smaller value than val)\n        \n        TreeNode left;\n        TreeNode right;\n        \n        public TreeNode(int val) {\n            this.val = val;\n            this.freq = 1;\n            this.countLeft = 0;\n        }\n    }\n    \n    class AVLTree {\n        TreeNode root;\n        \n        AVLTree(int val) {\n            this.root = new TreeNode(val);\n        }\n\n        void updateHeight(TreeNode n) {\n            n.height = 1 + Math.max(height(n.left), height(n.right));\n        }\n\n        int height(TreeNode n) {\n            return n == null ? -1 : n.height;\n        }\n\n        int getBalance(TreeNode n) {\n            return (n == null) ? 0 : height(n.right) - height(n.left);\n        }\n        \n        TreeNode rotateRight(TreeNode y) {\n            TreeNode x = y.left;\n            TreeNode B = x.right;\n            x.right = y;\n            y.left = B;\n            \n            y.countLeft = y.countLeft - x.countLeft - x.freq;\n            \n            updateHeight(y);\n            updateHeight(x);\n            return x;\n        }\n        \n        TreeNode rotateLeft(TreeNode y) {\n            TreeNode x = y.right;\n            TreeNode B = x.left;\n            x.left = y;\n            y.right = B;\n            \n            x.countLeft = x.countLeft + y.countLeft + y.freq;\n            \n            updateHeight(y);\n            updateHeight(x);\n            return x;\n        }\n        \n        TreeNode rebalance(TreeNode z) {\n            updateHeight(z);\n            int balance = getBalance(z);\n            if (balance > 1) {\n                if (height(z.right.right) > height(z.right.left)) {\n                    z = rotateLeft(z);\n                } else {\n                    z.right = rotateRight(z.right);\n                    z = rotateLeft(z);\n                }\n            } else if (balance < -1) {\n                if (height(z.left.left) > height(z.left.right))\n                    z = rotateRight(z);\n                else {\n                    z.left = rotateLeft(z.left);\n                    z = rotateRight(z);\n                }\n            }\n            return z;\n        }\n        \n\n        int total = 0;  // recording the result after each insertion\n        \n        TreeNode insert(TreeNode node, int key, int count) {\n            if (node == null) {\n                total = count;\n                return new TreeNode(key);\n            }\n            \n            \n            if (node.val > key) {\n                node.countLeft++;\n                \n                node.left = insert(node.left, key, count);\n            } else if (node.val < key){\n                count = count + node.countLeft + node.freq;\n                \n                node.right = insert(node.right, key, count);\n            } else {\n                node.freq++;\n                count = count + node.countLeft;\n                \n                total = count;\n            }\n            \n            return rebalance(node);\n        }        \n  \n    }\n    \n    \n    \n    public List<Integer> countSmaller(int[] nums) {\n        List<Integer> res = new LinkedList<>();\n        \n        int n = nums.length;\n        AVLTree avlTree = new AVLTree(nums[n-1]);\n        res.add(0);\n        \n        for (int i = n-2; i >= 0; i--) {\n            avlTree.root = avlTree.insert(avlTree.root, nums[i], 0);\n        \n            res.add(0, avlTree.total);\n            avlTree.total = 0;\n        }\n        \n        return res;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-of-smaller-numbers-after-self"}