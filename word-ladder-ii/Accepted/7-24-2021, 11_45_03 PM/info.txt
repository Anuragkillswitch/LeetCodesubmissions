{"id":527661854,"lang":"java","time":"13 hours, 22 minutes","timestamp":1627150503,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/527661854/","is_pending":"Not Pending","title":"Word Ladder II","memory":"39.9 MB","code":"class Pair {\n    String word1;\n    String word2;\n    Pair parent;\n    \n    public Pair(String word1, String word2, Pair parent){\n        this.word1 = word1;\n        this.word2 = word2;\n        this.parent = parent;\n    }\n}\n\nclass Solution {\n    \n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        List<List<String>> result = new LinkedList();\n        \n        boolean pathFound = false;\n        int currentLevel = 0;\n        \n        //indexes of words that has not been used before\n        List<Integer> notOperatedIndexes = new LinkedList();\n        for (int i=0;i<wordList.size();i++) notOperatedIndexes.add(i);\n        //indexes that were adeed to the current level and will be deleted from the notOperatedIndexes list\n        HashSet<Integer> indexesToDelete = new HashSet();\n        \n        //pares of the current level and pares of the next level\n        ArrayList<Pair> currentLevelPairs = new ArrayList();\n        ArrayList<Pair> nextLevelPairs = new ArrayList();\n        \n        //the first pare with the begin word\n        Pair firstPair = new Pair(null, beginWord, null);\n        currentLevelPairs.add(firstPair);\n        \n        //the worst case is if the only sequence contains all the words\n        while (currentLevel<wordList.size() && !pathFound){\n            currentLevel++;\n            \n            //get the words that were not used and check if they work for the current word.\n            for (Pair pair:currentLevelPairs){\n                for (Integer index:notOperatedIndexes){\n                    String currentWord = wordList.get(index);\n                    if (numberOfDifferentCharacters(pair.word2,currentWord)!=1) continue;\n                    if (currentWord.equals(endWord)) pathFound=true;\n                    indexesToDelete.add(index);\n                    nextLevelPairs.add(new Pair(pair.word2,currentWord,pair));\n                }\n            }\n            \n            //remove all the words that were used during this step from the pool of not used words\n            for (Integer index:indexesToDelete)\n                notOperatedIndexes.remove(index);\n            \n            currentLevelPairs = new ArrayList(nextLevelPairs);\n            nextLevelPairs.clear();\n            \n        }\n        \n        //all the paths were found and are kept in pairs, in currentLevelPairs variable\n        //there's need to go through them and save words in the result list.\n        \n        //Collect the paths\n        LinkedList<String> path;\n        for (Pair pair:currentLevelPairs){\n            if (!pair.word2.equals(endWord)) continue; //this sequence is usefull, because doesn't contain the end word\n            path = new LinkedList();\n            Pair currentPair = pair;\n            path.addFirst(currentPair.word2); //this is why I used a Linked list\n            while(currentPair.parent!=null){\n                path.addFirst(currentPair.word1);\n                currentPair = currentPair.parent;\n            }\n            result.add(path);\n        }\n                \n        return result;\n    }\n            \n    private int numberOfDifferentCharacters(String string1, String string2){\n        int result=0;\n        char[] c1=string1.toCharArray();\n        char[] c2=string2.toCharArray();\n        for (int i=0;i<string1.length();i++){\n            if (c1[i]!=c2[i])\n                result++;\n        }\n        return result;\n    }\n}","compare_result":"11111111111111111111111111111111","title_slug":"word-ladder-ii"}