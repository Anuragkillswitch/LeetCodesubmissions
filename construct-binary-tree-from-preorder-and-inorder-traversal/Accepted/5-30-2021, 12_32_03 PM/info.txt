{"id":500255078,"lang":"java","time":"1 month, 3 weeks","timestamp":1622358123,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/500255078/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"38.3 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n     public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        \n        Deque<TreeNode> stack = new ArrayDeque<>();\n        TreeNode root = new TreeNode(preorder[0]);\n        stack.push(root);\n        int inIndex = 0;\n        for (int i = 1; i < preorder.length; i++) {\n            TreeNode pre = null;\n            \n            // check if left ended, we need to pop up and go right\n            while (!stack.isEmpty() && stack.peek().val == inorder[inIndex]) {\n                inIndex++;\n                pre = stack.pop();\n            }\n            TreeNode node = new TreeNode(preorder[i]);\n            if (pre == null) {\n                // still go left\n                stack.peek().left = node;\n            } else {\n                // go right\n                pre.right = node;\n            }\n            stack.push(node);\n        }\n        \n        return root;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}