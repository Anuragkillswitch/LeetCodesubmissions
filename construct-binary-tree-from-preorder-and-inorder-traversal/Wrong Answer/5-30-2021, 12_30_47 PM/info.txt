{"id":500254603,"lang":"java","time":"1 month, 3 weeks","timestamp":1622358047,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/500254603/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"N/A","code":"class Solution {\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n\n    int root = preorder[0];\n    \n    List<Integer> leftTree = new LinkedList<>();\n    List<Integer> rightTree = new LinkedList<>();\n    \n    boolean foundRoot = false;\n    for(int i=0;i<inorder.length;i++){\n        if(inorder[i] == root){\n            foundRoot = true;\n        }\n        \n        if(foundRoot ){\n            rightTree.add(inorder[i]);\n        }else{\n            leftTree.add(inorder[i]);\n        }\n    }\n    \n    rightTree.remove(0);\n    \n    \n    List<Integer> leftTreePreOrder = new LinkedList<>();\n    List<Integer> rightTreePreOrder = new LinkedList<>();\n    \n    for(int i=0;i<preorder.length;i++){\n        if(leftTree.contains(preorder[i])){\n            leftTreePreOrder.add(preorder[i]);\n        }\n    }\n    \n     for(int i=0;i<preorder.length;i++){\n        if(rightTree.contains(preorder[i])){\n            rightTreePreOrder.add(preorder[i]);\n        }\n    }\n    \n    TreeNode leftTreeNode = buildBinaryTree(leftTreePreOrder);\n    TreeNode rightTreeNode = buildBinaryTree(rightTreePreOrder);\n    \n    TreeNode rootNode = new TreeNode(root,leftTreeNode, rightTreeNode);\n    \n    return rootNode;\n}\n\n\nprivate TreeNode buildBinaryTree(List<Integer> vals){\n   TreeNode root = null;\n    \n    for(int i=0;i<vals.size();i++){\n        TreeNode node = new TreeNode(vals.get(i), null, null);\n    \n        if(root == null){\n            root = node;\n        }else{\n            Queue<TreeNode> queue = new LinkedList<>();\n            queue.add(root);\n\n            while(queue.size() > 0){\n                 TreeNode currNode = queue.poll();\n\n                if(currNode.left != null){\n                    queue.add(currNode.left);\n                }else{\n                    currNode.left = node;\n                    break;\n                }\n\n                if(currNode.right != null){\n                    queue.add(currNode.right);\n                }else{\n                    currNode.right = node;\n                    break;\n                }\n            }\n        }\n    }\n    \n    return root;\n}\n}","compare_result":"1111110010010001010010000000000000000000100000100100000000000000000000000000000000000000000000000000000000000000000000000000000001000000010000000000000000000000000000000000000000000000000000000000000000","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}