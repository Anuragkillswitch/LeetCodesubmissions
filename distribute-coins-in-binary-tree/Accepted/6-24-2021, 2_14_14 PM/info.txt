{"id":512476360,"lang":"java","time":"1Â month","timestamp":1624524254,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/512476360/","is_pending":"Not Pending","title":"Distribute Coins in Binary Tree","memory":"38.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int ans;\n    public int distributeCoins(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    public int dfs(TreeNode node) {\n        if (node == null) return 0;\n        int L = dfs(node.left);\n        int R = dfs(node.right);\n        ans += Math.abs(L) + Math.abs(R);\n        return node.val + L + R - 1;\n    }\n}\n\n/*So I tried for a while to understand the problem and came up with a solution. I hope this explanation helps to anyone struggling to understand. \nHere's my perception:\nImagine a small tree [1,0,2]. We will try to calculate the difference of coins any node needs. To fulfil the difference, it will have to take or give coins to its parent node. It is a bottom-up approach so we don't have to deal with any node's children.\nWe will start from the left-most leaf which is 0. It gives (-1) coins or takes one coin from the parent to be balanced. So we add a move. Next, we traverse the right child that has 2 coins. It gives 1 coin to the root node, so 1 move. Atlast, we visit the root node, for which difference will be sum of differences from left and right nodes plus its value. For the last root node, the difference will always be 0.\nHere's the code:\n\nclass Solution {\n    private int moves = 0;\n    private int current = 0;\n    public int distributeCoins(TreeNode root) {\n        dfs(root);\n        return moves;\n    }\n    public int dfs(TreeNode root) {\n        if(root==null) return 0;\n        int left = dfs(root.left);\n        int right = dfs(root.right);\n        int diff = left + right + root.val - 1;\n        moves += Math.abs(diff);\n        return diff;\n    }\n}\n\nTime Complexity - O(n)\nSpace Complexity - O(Height of tree)\n    */","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"distribute-coins-in-binary-tree"}