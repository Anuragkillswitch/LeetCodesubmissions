{"id":511583876,"lang":"java","time":"1Â month","timestamp":1624367013,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/511583876/","is_pending":"Not Pending","title":"Pseudo-Palindromic Paths in a Binary Tree","memory":"66.3 MB","code":"class Solution {\n    int c=0;\n    public int pseudoPalindromicPaths (TreeNode root) {\n        int countFreq[]=new int[10];\n        \n        find(root,countFreq);\n        return c;\n        \n    }\n    private void find(TreeNode root,int countFrequencies[]){\n        if(root==null) return;\n        if(root.left==null && root.right==null){ //Leaf node reached\n             countFrequencies[root.val]++;\n            int odd=0;\n            for(int i=0;i<10;i++){\n                if((countFrequencies[i]&1)!=0) odd++;\n            }\n            if(odd<2) c++; //If zero or 1's frequency is odd then we can construct a palindrome otherwise if more than one number has odd frequency it is not possible to construct a palindrome using that!\n            countFrequencies[root.val]--;\n            return;\n        }\n        countFrequencies[root.val]++; //Adding the current node's val \n        find(root.left,countFrequencies); \n        find(root.right,countFrequencies);\n        countFrequencies[root.val]--;//Removing the current node's value\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111","title_slug":"pseudo-palindromic-paths-in-a-binary-tree"}