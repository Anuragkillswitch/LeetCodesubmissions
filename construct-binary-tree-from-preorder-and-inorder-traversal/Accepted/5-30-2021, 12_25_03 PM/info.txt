{"id":500252513,"lang":"java","time":"1 month, 3 weeks","timestamp":1622357703,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/500252513/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"38.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return  helper(0,0,inorder.length-1,preorder,inorder);\n    }\n    \n    private TreeNode helper(int preStart,int inStart,int inEnd,int[] preorder,int[] inorder)\n    {\n        if(preStart>preorder.length-1 || inStart>inEnd)\n             return null;\n        \n        TreeNode root=new TreeNode(preorder[preStart]);\n        int index=0;\n        for(int i=inStart;i<=inEnd;i++)\n        {\n            if(inorder[i]==preorder[preStart]) //Position of root in inOrder array\n                 index=i;\n        }\n        \n        \n        \n        \n        root.left=helper(preStart+1,inStart,index-1,preorder,inorder);\n        root.right=helper(preStart+index-inStart+1,index+1,inEnd,preorder,inorder);\n                         //index-inStart This is on the left side\n                         //So we skip all the left stuff of the inorder array and then we add 1\n            \n            \n            \n            \n        return root;    \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}