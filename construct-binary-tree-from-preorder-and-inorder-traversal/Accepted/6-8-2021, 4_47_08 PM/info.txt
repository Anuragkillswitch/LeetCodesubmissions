{"id":504884011,"lang":"java","time":"1 month, 2 weeks","timestamp":1623151028,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/504884011/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"38.4 MB","code":"class Solution {\n     public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        \n        Deque<TreeNode> stack = new ArrayDeque<>();\n        TreeNode root = new TreeNode(preorder[0]);\n        stack.push(root);\n        int inIndex = 0;\n        for (int i = 1; i < preorder.length; i++) {\n            TreeNode pre = null;\n            \n            // check if left ended, we need to pop up and go right\n            while (!stack.isEmpty() && stack.peek().val == inorder[inIndex]) {\n                inIndex++;\n                pre = stack.pop();\n            }\n            TreeNode node = new TreeNode(preorder[i]);\n            if (pre == null) {\n                // still go left\n                stack.peek().left = node;\n            } else {\n                // go right\n                pre.right = node;\n            }\n            stack.push(node);\n        }\n        \n        return root;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}