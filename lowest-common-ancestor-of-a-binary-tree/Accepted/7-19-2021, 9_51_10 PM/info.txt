{"id":525033508,"lang":"java","time":"5 days, 15 hours","timestamp":1626711670,"status_display":"Accepted","runtime":"9 ms","url":"/submissions/detail/525033508/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"40.4 MB","code":"class Solution {\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        // Stack for tree traversal\n        Deque<TreeNode> stack = new ArrayDeque<>();\n\n        // HashMap for parent pointers\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n\n        parent.put(root, null);\n        stack.push(root);\n\n        // Iterate until we find both the nodes p and q\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\n\n            TreeNode node = stack.pop();\n\n            // While traversing the tree, keep saving the parent pointers.\n            if (node.left != null) {\n                parent.put(node.left, node);\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                parent.put(node.right, node);\n                stack.push(node.right);\n            }\n        }\n\n        // Ancestors set() for node p.\n        Set<TreeNode> ancestors = new HashSet<>();\n\n        // Process all ancestors for node p using parent pointers.\n        while (p != null) {\n            ancestors.add(p);\n            p = parent.get(p);\n        }\n\n        // The first ancestor of q which appears in\n        // p's ancestor set() is their lowest common ancestor.\n        while (!ancestors.contains(q))\n            q = parent.get(q);\n        return q;\n    }\n\n}","compare_result":"1111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree"}