{"id":504058819,"lang":"java","time":"1 month, 2 weeks","timestamp":1623009244,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/504058819/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Postorder Traversal","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n       return helper(pre,post,0,pre.length-1,0,post.length-1); \n    }\n    \n    private TreeNode helper(int[] pre,int[] post,int preStart,int preEnd,int postStart,int postEnd)\n    {\n        if(preStart>preEnd)\n            return null;\n        \n        TreeNode root=new TreeNode(pre[preStart]);\n        \n        \n        if(preStart==preEnd) //Last node case is returned here so Point B wont be triggered\n           return root;\n        \n        int postIndex=postStart; //Index in postOrder where the root value exists!\n        while(post[postIndex++]!=pre[preStart+1]); //Point B\n        \n        int len=postIndex-postStart+1;\n        root.left=helper(pre,post,preStart+1,preStart+len,postStart,postIndex);\n        root.right=helper(pre,post,preStart+len+1,preEnd,postIndex+1,postEnd-1);\n        return root;\n        \n        \n        \n    }\n}","compare_result":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"construct-binary-tree-from-preorder-and-postorder-traversal"}