{"id":482967317,"lang":"c","time":"3Â months","timestamp":1618909518,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/482967317/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\n\nvoid traverse(struct TreeNode *root, int depth, int ***arr, int **columnSizes, int *returnSize)\n{\n    if (!root) return;\n\n    if (*returnSize < depth + 1) {\n        *returnSize = depth + 1;\n        \n        /*\n         * Should initialise the one more allocated space to NULL (or 0)\n         */\n        *arr = realloc(*arr, (depth + 1) * sizeof(int *));\n        (*arr)[depth] = NULL;\n    \n        *columnSizes = realloc(*columnSizes, (depth + 1) * sizeof(int));\n        (*columnSizes)[depth] = 0;\n    }\n    \n    (*arr)[depth] = realloc((*arr)[depth], ((*columnSizes)[depth] + 1) * sizeof(int));\n    (*arr)[depth][(*columnSizes)[depth]] = root->val;\n    ++(*columnSizes)[depth];\n    \n    traverse(root->left, depth + 1, arr, columnSizes, returnSize);\n    traverse(root->right, depth + 1, arr, columnSizes, returnSize);\n}\n\nint** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {\n    int **arr;\n    \n    arr = NULL;\n    *returnSize = 0;\n    traverse(root, 0, &arr, columnSizes, returnSize);\n    \n    return arr;\n}","compare_result":"0000000000000000000000000000000000","title_slug":"binary-tree-level-order-traversal"}